// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: mcp.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Metadata } from "./common";
export const protobufPackage = "valoride";
export var McpServerStatus;
(function (McpServerStatus) {
    /**
     * MCP_SERVER_STATUS_DISCONNECTED - Protobuf enums (in proto3) must have a zero value defined, which serves as the default if the field isn't explicitly set.
     * To align with the required nature of the TypeScript type and avoid an unnecessary UNSPECIFIED state, we map one of the existing statuses to this zero value.
     */
    McpServerStatus[McpServerStatus["MCP_SERVER_STATUS_DISCONNECTED"] = 0] = "MCP_SERVER_STATUS_DISCONNECTED";
    McpServerStatus[McpServerStatus["MCP_SERVER_STATUS_CONNECTED"] = 1] = "MCP_SERVER_STATUS_CONNECTED";
    McpServerStatus[McpServerStatus["MCP_SERVER_STATUS_CONNECTING"] = 2] = "MCP_SERVER_STATUS_CONNECTING";
    McpServerStatus[McpServerStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(McpServerStatus || (McpServerStatus = {}));
export function mcpServerStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "MCP_SERVER_STATUS_DISCONNECTED":
            return McpServerStatus.MCP_SERVER_STATUS_DISCONNECTED;
        case 1:
        case "MCP_SERVER_STATUS_CONNECTED":
            return McpServerStatus.MCP_SERVER_STATUS_CONNECTED;
        case 2:
        case "MCP_SERVER_STATUS_CONNECTING":
            return McpServerStatus.MCP_SERVER_STATUS_CONNECTING;
        case -1:
        case "UNRECOGNIZED":
        default:
            return McpServerStatus.UNRECOGNIZED;
    }
}
export function mcpServerStatusToJSON(object) {
    switch (object) {
        case McpServerStatus.MCP_SERVER_STATUS_DISCONNECTED:
            return "MCP_SERVER_STATUS_DISCONNECTED";
        case McpServerStatus.MCP_SERVER_STATUS_CONNECTED:
            return "MCP_SERVER_STATUS_CONNECTED";
        case McpServerStatus.MCP_SERVER_STATUS_CONNECTING:
            return "MCP_SERVER_STATUS_CONNECTING";
        case McpServerStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseToggleMcpServerRequest() {
    return { metadata: undefined, serverName: "", disabled: false };
}
export const ToggleMcpServerRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.serverName !== "") {
            writer.uint32(18).string(message.serverName);
        }
        if (message.disabled !== false) {
            writer.uint32(24).bool(message.disabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseToggleMcpServerRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.serverName = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.disabled = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata)
                ? Metadata.fromJSON(object.metadata)
                : undefined,
            serverName: isSet(object.serverName)
                ? globalThis.String(object.serverName)
                : "",
            disabled: isSet(object.disabled)
                ? globalThis.Boolean(object.disabled)
                : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.serverName !== "") {
            obj.serverName = message.serverName;
        }
        if (message.disabled !== false) {
            obj.disabled = message.disabled;
        }
        return obj;
    },
    create(base) {
        return ToggleMcpServerRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseToggleMcpServerRequest();
        message.metadata =
            object.metadata !== undefined && object.metadata !== null
                ? Metadata.fromPartial(object.metadata)
                : undefined;
        message.serverName = object.serverName ?? "";
        message.disabled = object.disabled ?? false;
        return message;
    },
};
function createBaseUpdateMcpTimeoutRequest() {
    return { metadata: undefined, serverName: "", timeout: 0 };
}
export const UpdateMcpTimeoutRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.serverName !== "") {
            writer.uint32(18).string(message.serverName);
        }
        if (message.timeout !== 0) {
            writer.uint32(24).int32(message.timeout);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateMcpTimeoutRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.serverName = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.timeout = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata)
                ? Metadata.fromJSON(object.metadata)
                : undefined,
            serverName: isSet(object.serverName)
                ? globalThis.String(object.serverName)
                : "",
            timeout: isSet(object.timeout) ? globalThis.Number(object.timeout) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        if (message.serverName !== "") {
            obj.serverName = message.serverName;
        }
        if (message.timeout !== 0) {
            obj.timeout = Math.round(message.timeout);
        }
        return obj;
    },
    create(base) {
        return UpdateMcpTimeoutRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUpdateMcpTimeoutRequest();
        message.metadata =
            object.metadata !== undefined && object.metadata !== null
                ? Metadata.fromPartial(object.metadata)
                : undefined;
        message.serverName = object.serverName ?? "";
        message.timeout = object.timeout ?? 0;
        return message;
    },
};
function createBaseMcpTool() {
    return {
        name: "",
        description: undefined,
        inputSchema: undefined,
        autoApprove: undefined,
    };
}
export const McpTool = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.description !== undefined) {
            writer.uint32(18).string(message.description);
        }
        if (message.inputSchema !== undefined) {
            writer.uint32(26).string(message.inputSchema);
        }
        if (message.autoApprove !== undefined) {
            writer.uint32(32).bool(message.autoApprove);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMcpTool();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.inputSchema = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.autoApprove = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            description: isSet(object.description)
                ? globalThis.String(object.description)
                : undefined,
            inputSchema: isSet(object.inputSchema)
                ? globalThis.String(object.inputSchema)
                : undefined,
            autoApprove: isSet(object.autoApprove)
                ? globalThis.Boolean(object.autoApprove)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        if (message.inputSchema !== undefined) {
            obj.inputSchema = message.inputSchema;
        }
        if (message.autoApprove !== undefined) {
            obj.autoApprove = message.autoApprove;
        }
        return obj;
    },
    create(base) {
        return McpTool.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMcpTool();
        message.name = object.name ?? "";
        message.description = object.description ?? undefined;
        message.inputSchema = object.inputSchema ?? undefined;
        message.autoApprove = object.autoApprove ?? undefined;
        return message;
    },
};
function createBaseMcpResource() {
    return { uri: "", name: "", mimeType: undefined, description: undefined };
}
export const McpResource = {
    encode(message, writer = new BinaryWriter()) {
        if (message.uri !== "") {
            writer.uint32(10).string(message.uri);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.mimeType !== undefined) {
            writer.uint32(26).string(message.mimeType);
        }
        if (message.description !== undefined) {
            writer.uint32(34).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMcpResource();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.uri = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.mimeType = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            mimeType: isSet(object.mimeType)
                ? globalThis.String(object.mimeType)
                : undefined,
            description: isSet(object.description)
                ? globalThis.String(object.description)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.uri !== "") {
            obj.uri = message.uri;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.mimeType !== undefined) {
            obj.mimeType = message.mimeType;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        return obj;
    },
    create(base) {
        return McpResource.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMcpResource();
        message.uri = object.uri ?? "";
        message.name = object.name ?? "";
        message.mimeType = object.mimeType ?? undefined;
        message.description = object.description ?? undefined;
        return message;
    },
};
function createBaseMcpResourceTemplate() {
    return {
        uriTemplate: "",
        name: "",
        mimeType: undefined,
        description: undefined,
    };
}
export const McpResourceTemplate = {
    encode(message, writer = new BinaryWriter()) {
        if (message.uriTemplate !== "") {
            writer.uint32(10).string(message.uriTemplate);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.mimeType !== undefined) {
            writer.uint32(26).string(message.mimeType);
        }
        if (message.description !== undefined) {
            writer.uint32(34).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMcpResourceTemplate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.uriTemplate = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.mimeType = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            uriTemplate: isSet(object.uriTemplate)
                ? globalThis.String(object.uriTemplate)
                : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            mimeType: isSet(object.mimeType)
                ? globalThis.String(object.mimeType)
                : undefined,
            description: isSet(object.description)
                ? globalThis.String(object.description)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.uriTemplate !== "") {
            obj.uriTemplate = message.uriTemplate;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.mimeType !== undefined) {
            obj.mimeType = message.mimeType;
        }
        if (message.description !== undefined) {
            obj.description = message.description;
        }
        return obj;
    },
    create(base) {
        return McpResourceTemplate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMcpResourceTemplate();
        message.uriTemplate = object.uriTemplate ?? "";
        message.name = object.name ?? "";
        message.mimeType = object.mimeType ?? undefined;
        message.description = object.description ?? undefined;
        return message;
    },
};
function createBaseMcpServer() {
    return {
        name: "",
        config: "",
        status: 0,
        error: undefined,
        tools: [],
        resources: [],
        resourceTemplates: [],
        disabled: undefined,
        timeout: undefined,
    };
}
export const McpServer = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.config !== "") {
            writer.uint32(18).string(message.config);
        }
        if (message.status !== 0) {
            writer.uint32(24).int32(message.status);
        }
        if (message.error !== undefined) {
            writer.uint32(34).string(message.error);
        }
        for (const v of message.tools) {
            McpTool.encode(v, writer.uint32(42).fork()).join();
        }
        for (const v of message.resources) {
            McpResource.encode(v, writer.uint32(50).fork()).join();
        }
        for (const v of message.resourceTemplates) {
            McpResourceTemplate.encode(v, writer.uint32(58).fork()).join();
        }
        if (message.disabled !== undefined) {
            writer.uint32(64).bool(message.disabled);
        }
        if (message.timeout !== undefined) {
            writer.uint32(72).int32(message.timeout);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMcpServer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.config = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.tools.push(McpTool.decode(reader, reader.uint32()));
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.resources.push(McpResource.decode(reader, reader.uint32()));
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.resourceTemplates.push(McpResourceTemplate.decode(reader, reader.uint32()));
                    continue;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.disabled = reader.bool();
                    continue;
                }
                case 9: {
                    if (tag !== 72) {
                        break;
                    }
                    message.timeout = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            config: isSet(object.config) ? globalThis.String(object.config) : "",
            status: isSet(object.status) ? mcpServerStatusFromJSON(object.status) : 0,
            error: isSet(object.error) ? globalThis.String(object.error) : undefined,
            tools: globalThis.Array.isArray(object?.tools)
                ? object.tools.map((e) => McpTool.fromJSON(e))
                : [],
            resources: globalThis.Array.isArray(object?.resources)
                ? object.resources.map((e) => McpResource.fromJSON(e))
                : [],
            resourceTemplates: globalThis.Array.isArray(object?.resourceTemplates)
                ? object.resourceTemplates.map((e) => McpResourceTemplate.fromJSON(e))
                : [],
            disabled: isSet(object.disabled)
                ? globalThis.Boolean(object.disabled)
                : undefined,
            timeout: isSet(object.timeout)
                ? globalThis.Number(object.timeout)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.config !== "") {
            obj.config = message.config;
        }
        if (message.status !== 0) {
            obj.status = mcpServerStatusToJSON(message.status);
        }
        if (message.error !== undefined) {
            obj.error = message.error;
        }
        if (message.tools?.length) {
            obj.tools = message.tools.map((e) => McpTool.toJSON(e));
        }
        if (message.resources?.length) {
            obj.resources = message.resources.map((e) => McpResource.toJSON(e));
        }
        if (message.resourceTemplates?.length) {
            obj.resourceTemplates = message.resourceTemplates.map((e) => McpResourceTemplate.toJSON(e));
        }
        if (message.disabled !== undefined) {
            obj.disabled = message.disabled;
        }
        if (message.timeout !== undefined) {
            obj.timeout = Math.round(message.timeout);
        }
        return obj;
    },
    create(base) {
        return McpServer.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMcpServer();
        message.name = object.name ?? "";
        message.config = object.config ?? "";
        message.status = object.status ?? 0;
        message.error = object.error ?? undefined;
        message.tools = object.tools?.map((e) => McpTool.fromPartial(e)) || [];
        message.resources =
            object.resources?.map((e) => McpResource.fromPartial(e)) || [];
        message.resourceTemplates =
            object.resourceTemplates?.map((e) => McpResourceTemplate.fromPartial(e)) || [];
        message.disabled = object.disabled ?? undefined;
        message.timeout = object.timeout ?? undefined;
        return message;
    },
};
function createBaseMcpServers() {
    return { mcpServers: [] };
}
export const McpServers = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.mcpServers) {
            McpServer.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMcpServers();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.mcpServers.push(McpServer.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            mcpServers: globalThis.Array.isArray(object?.mcpServers)
                ? object.mcpServers.map((e) => McpServer.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.mcpServers?.length) {
            obj.mcpServers = message.mcpServers.map((e) => McpServer.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return McpServers.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMcpServers();
        message.mcpServers =
            object.mcpServers?.map((e) => McpServer.fromPartial(e)) || [];
        return message;
    },
};
export const McpServiceDefinition = {
    name: "McpService",
    fullName: "valoride.McpService",
    methods: {
        toggleMcpServer: {
            name: "toggleMcpServer",
            requestType: ToggleMcpServerRequest,
            requestStream: false,
            responseType: McpServers,
            responseStream: false,
            options: {},
        },
        updateMcpTimeout: {
            name: "updateMcpTimeout",
            requestType: UpdateMcpTimeoutRequest,
            requestStream: false,
            responseType: McpServers,
            responseStream: false,
            options: {},
        },
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=mcp.js.map