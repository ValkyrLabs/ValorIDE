import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React, { useState, useEffect } from "react";
import { Modal, Form as BSForm, Row, Col, Alert, Table, Spinner, ButtonGroup, } from "react-bootstrap";
import LoadingSpinner from "@valkyr/component-library/LoadingSpinner";
import { FaLock, FaUnlock, FaUserShield, FaUsers, FaSuperpowers, FaTrash, } from "react-icons/fa";
// custom redux for ACL granting
import { useGrantAclPermissionMutation, useRevokeAclPermissionMutation, useGetRolesQuery, useGetObjectAclEntriesQuery, useDenyAclPermissionMutation, } from "../../redux/services/AclService";
import CoolButton from "@valkyr/component-library/CoolButton";
import { invalidateEntityById } from "../../redux/cache/rtkInvalidate";
/**
############################## DO NOT EDIT: GENERATED FILE ##############################

Generated by Valkyr Labs ThorAPI: https://valkyrlabs.com/thorapi
Powered by Swagger Codegen: http://swagger.io

Generated Details:
**GENERATOR VERSION:** {{{generatorVersion}}}
**GENERATED DATE:** {{generatedDate}}
**GENERATOR CLASS:** {{generatorClass}}

Template file: typescript-redux-query/components/PermissionDialog.tsx.mustache

############################## DO NOT EDIT: GENERATED FILE ##############################
*/
import { PermissionType, } from "./types";
export const PermissionDialog = ({ objectType, objectId, isVisible, onClose, onSave, currentUser, }) => {
    const [assignments, setAssignments] = useState([]);
    const [newAssignment, setNewAssignment] = useState({
        username: "",
        permissions: [],
        isRole: false,
    });
    const [showAlert, setShowAlert] = useState(null);
    // RTK Query hooks
    const [grantPermission, { isLoading: isGranting }] = useGrantAclPermissionMutation();
    const [revokePermission, { isLoading: isRevoking }] = useRevokeAclPermissionMutation();
    const [denyPermission, { isLoading: isDenying }] = useDenyAclPermissionMutation();
    const { data: roles = [], isLoading: rolesLoading } = useGetRolesQuery();
    const rolesPlusSystem = React.useMemo(() => {
        const hasSystem = roles.some((r) => (r.roleName || r.role) === "SYSTEM");
        return hasSystem
            ? roles
            : [...roles, { id: "SYSTEM", roleName: "SYSTEM", role: "CUSTOM" }];
    }, [roles]);
    const { data: existingEntries = [], isLoading: entriesLoading, refetch: refetchEntries, } = useGetObjectAclEntriesQuery({ objectType, objectId });
    // Check if current user can manage permissions
    const canManagePermissions = true; // for now... check back on solution
    useEffect(() => {
        if (existingEntries.length > 0) {
            // Group existing entries by username
            const grouped = existingEntries.reduce((acc, entry) => {
                if (!acc[entry.username]) {
                    acc[entry.username] = {
                        username: entry.username,
                        permissions: [],
                        isRole: false, // We'll need to determine this from the username format
                    };
                }
                if (entry.granted) {
                    acc[entry.username].permissions.push(entry.permission);
                }
                return acc;
            }, {});
            setAssignments(Object.values(grouped));
        }
    }, [existingEntries]);
    const handlePermissionToggle = (permission, checked) => {
        setNewAssignment((prev) => ({
            ...prev,
            permissions: checked
                ? [...prev.permissions, permission]
                : prev.permissions.filter((p) => p !== permission),
        }));
    };
    const handleAddAssignment = () => {
        if (!newAssignment.username || newAssignment.permissions.length === 0) {
            setShowAlert({
                type: "error",
                message: "Please select a user/role and at least one permission.",
            });
            return;
        }
        setAssignments((prev) => [...prev, { ...newAssignment }]);
        setNewAssignment({
            username: "",
            permissions: [],
            isRole: false,
        });
    };
    // Convenience: quickly assign SYSTEM decrypt permission
    const grantSystemDecrypt = () => {
        setAssignments((prev) => [
            ...prev,
            {
                username: "SYSTEM",
                isRole: false,
                permissions: [PermissionType.VIEW_DECRYPTED],
            },
        ]);
    };
    // Convenience: quickly assign ANONYMOUS READ
    const grantAnonymousRead = () => {
        setAssignments((prev) => [
            ...prev,
            {
                username: "anonymousUser",
                isRole: false,
                permissions: [PermissionType.READ],
            },
        ]);
    };
    // Convenience: Deny EVERYONE all permissions (testing only)
    const denyEveryoneAll = async () => {
        try {
            const perms = [
                PermissionType.READ,
                PermissionType.WRITE,
                PermissionType.CREATE,
                PermissionType.DELETE,
                PermissionType.ADMINISTRATION,
                PermissionType.VIEW_DECRYPTED,
            ];
            for (const p of perms) {
                await denyPermission({
                    objectType,
                    objectId,
                    username: "EVERYONE",
                    permission: p,
                }).unwrap();
            }
            setShowAlert({
                type: "success",
                message: "Denied EVERYONE all base permissions for this object.",
            });
            setTimeout(() => refetchEntries(), 300);
        }
        catch (e) {
            setShowAlert({
                type: "error",
                message: "Failed to deny EVERYONE permissions.",
            });
        }
    };
    const handleRemoveAssignment = (index) => {
        setAssignments((prev) => prev.filter((_, i) => i !== index));
    };
    const handleSave = async () => {
        if (!canManagePermissions) {
            setShowAlert({
                type: "error",
                message: "You do not have permission to manage object permissions.",
            });
            return;
        }
        try {
            // Convert assignments to grant requests
            const grantRequests = [];
            assignments.forEach((assignment) => {
                assignment.permissions.forEach((permission) => {
                    grantRequests.push({
                        objectType,
                        objectId,
                        username: assignment.username,
                        permission,
                    });
                });
            });
            // First revoke all existing permissions, then grant new ones
            for (const entry of existingEntries) {
                if (entry.granted) {
                    await revokePermission({
                        objectType,
                        objectId,
                        username: entry.username,
                        permission: entry.permission,
                    }).unwrap();
                }
            }
            // Grant new permissions
            for (const request of grantRequests) {
                await grantPermission(request).unwrap();
            }
            setShowAlert({
                type: "success",
                message: "Permissions updated successfully!",
            });
            onSave(grantRequests);
            // Refetch entries to update the display
            setTimeout(() => {
                refetchEntries();
            }, 500);
            // Invalidate caches for the affected object so lists/details refresh
            try {
                if (objectId && objectType) {
                    invalidateEntityById(objectType, objectId);
                }
            }
            catch { }
        }
        catch (error) {
            console.error("Error updating permissions:", error);
            setShowAlert({
                type: "error",
                message: "Failed to update permissions. Please try again.",
            });
        }
    };
    const handleClose = () => {
        setAssignments([]);
        setNewAssignment({ username: "", permissions: [], isRole: false });
        setShowAlert(null);
        onClose();
    };
    if (!canManagePermissions) {
        return (_jsxs(Modal, { show: isVisible, onHide: handleClose, size: "sm", centered: true, children: [_jsx(Modal.Header, { closeButton: true, children: _jsxs(Modal.Title, { children: [_jsx(FaLock, {}), " Access Denied"] }) }), _jsx(Modal.Body, { children: _jsx(Alert, { variant: "warning", children: "You do not have permission to manage permissions for this object. Only owners and administrators can modify object permissions." }) }), _jsx(Modal.Footer, { children: _jsx(CoolButton, { variant: "secondary", onClick: handleClose, children: "Close" }) })] }));
    }
    return (_jsxs(Modal, { show: isVisible, onHide: handleClose, size: "xl", centered: true, children: [_jsx(Modal.Header, { closeButton: true, children: _jsxs(Modal.Title, { children: [_jsx(FaUserShield, {}), " Manage Permissions - ", objectType] }) }), _jsxs(Modal.Body, { children: [showAlert && (_jsx(Alert, { variant: showAlert.type === "success" ? "success" : "danger", onClose: () => setShowAlert(null), dismissible: true, children: showAlert.message })), _jsxs("div", { className: "mb-4", children: [_jsxs("h5", { children: [_jsx(FaUsers, {}), " Current Permissions"] }), _jsxs("div", { className: "mb-2", children: [_jsx(CoolButton, { variant: "outline-warning", size: "sm", onClick: grantSystemDecrypt, children: "Grant SYSTEM decrypt" }), _jsx(CoolButton, { variant: "outline-success", size: "sm", className: "ms-2", onClick: grantAnonymousRead, children: "Grant ANONYMOUS read" }), _jsx(CoolButton, { variant: "outline-danger", size: "sm", className: "ms-2", onClick: denyEveryoneAll, children: "Deny EVERYONE all" })] }), entriesLoading ? (_jsx("div", { className: "text-center", children: _jsx(LoadingSpinner, { label: "Loading permissions\u2026", size: 18 }) })) : (_jsxs(Table, { striped: true, bordered: true, hover: true, size: "sm", children: [_jsx("thead", { children: _jsxs("tr", { children: [_jsx("th", { children: _jsx(FaTrash, {}) }), _jsx("th", { children: "User/Role" }), _jsx("th", { children: "R" }), _jsx("th", { children: "W" }), _jsx("th", { children: "C" }), _jsx("th", { children: "D" }), _jsx("th", { children: _jsx(FaSuperpowers, {}) })] }) }), _jsxs("tbody", { children: [assignments.map((assignment, index) => (_jsxs("tr", { children: [_jsx("td", { children: _jsx(CoolButton, { variant: "danger", size: "sm", onClick: () => handleRemoveAssignment(index), children: _jsx(FaTrash, {}) }) }), _jsxs("td", { children: [assignment.isRole ? _jsx(FaUsers, {}) : _jsx(FaUserShield, {}), " ", assignment.username] }), Object.values(PermissionType).map((permission) => (_jsx("td", { className: "text-center", children: assignment.permissions.includes(permission) ? (_jsx(FaUnlock, { className: "text-primary-emphasis" })) : (_jsx(FaLock, { className: "text-muted" })) }, permission)))] }, index))), assignments.length === 0 && (_jsx("tr", { children: _jsx("td", { colSpan: 7, className: "text-center text-muted", children: "No permissions assigned" }) }))] })] })), !entriesLoading && existingEntries.some((e) => !e.granted) && (_jsxs("div", { className: "mt-2", children: [_jsx("h6", { children: "Explicit Denies" }), _jsxs(Table, { bordered: true, size: "sm", children: [_jsx("thead", { children: _jsxs("tr", { children: [_jsx("th", { children: "User/Role" }), _jsx("th", { children: "Permission" }), _jsx("th", { children: "Status" })] }) }), _jsx("tbody", { children: existingEntries
                                                    .filter((e) => !e.granted)
                                                    .map((e, i) => (_jsxs("tr", { children: [_jsx("td", { children: e.username }), _jsx("td", { children: e.permission }), _jsx("td", { className: "text-danger", children: "DENY" })] }, `deny-${i}`))) })] })] }))] }), _jsxs("div", { className: "border p-3 rounded", children: [_jsx("h5", { children: "Add New Permission" }), _jsxs(Row, { children: [_jsx(Col, { md: 6, children: _jsxs(BSForm.Group, { className: "mb-3", children: [_jsx(BSForm.Label, { children: "Assignment Type" }), _jsxs(ButtonGroup, { className: "d-block", children: [_jsxs(CoolButton, { variant: !newAssignment.isRole ? "primary" : "outline-primary", onClick: () => setNewAssignment((prev) => ({
                                                                ...prev,
                                                                isRole: false,
                                                                username: "",
                                                            })), children: [_jsx(FaUserShield, {}), " User"] }), _jsxs(CoolButton, { variant: newAssignment.isRole ? "primary" : "outline-primary", onClick: () => setNewAssignment((prev) => ({
                                                                ...prev,
                                                                isRole: true,
                                                                username: "",
                                                            })), children: [_jsx(FaUsers, {}), " Role"] })] })] }) }), _jsx(Col, { md: 6, children: _jsxs(BSForm.Group, { className: "mb-3", children: [_jsx(BSForm.Label, { children: newAssignment.isRole ? "Select Role" : "Username" }), newAssignment.isRole ? (_jsxs(BSForm.Select, { value: newAssignment.username, onChange: (e) => setNewAssignment((prev) => ({
                                                        ...prev,
                                                        username: e.target.value,
                                                    })), disabled: rolesLoading, children: [_jsx("option", { value: "", children: "Select a role..." }), rolesPlusSystem.map((role) => (_jsx("option", { value: role.roleName || role.role, children: role.roleName || role.role }, role.id)))] })) : (_jsx(BSForm.Control, { type: "text", placeholder: "Enter username", value: newAssignment.username, onChange: (e) => setNewAssignment((prev) => ({
                                                        ...prev,
                                                        username: e.target.value,
                                                    })) }))] }) })] }), _jsxs(BSForm.Group, { className: "mb-3", children: [_jsx(BSForm.Label, { children: "Permissions" }), _jsx(Row, { children: Object.values(PermissionType).map((permission) => (_jsx(Col, { md: 4, sm: 6, children: _jsx(BSForm.Check, { type: "checkbox", id: `perm-${permission}`, label: permission, checked: newAssignment.permissions.includes(permission), onChange: (e) => handlePermissionToggle(permission, e.target.checked) }) }, permission))) })] }), _jsx(CoolButton, { variant: "success", onClick: handleAddAssignment, children: "Add Permission" })] })] }), _jsxs(Modal.Footer, { children: [_jsx(CoolButton, { variant: "secondary", onClick: handleClose, children: "Cancel" }), _jsxs(CoolButton, { variant: "primary", onClick: handleSave, disabled: isGranting || isRevoking, children: [(isGranting || isRevoking) && (_jsx(Spinner, { animation: "border", size: "sm", className: "me-2" })), "Save Permissions"] })] })] }));
};
//# sourceMappingURL=index.js.map