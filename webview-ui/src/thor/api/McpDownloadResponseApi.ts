// tslint:disable

/**
############################## DO NOT EDIT: GENERATED FILE ##############################

Generated by Valkyr Labs ThorAPI: https://valkyrlabs.com

Powered by Swagger Codegen: http://swagger.io

Generator version: (7.5.0)

Template file: typescript-redux-query/apis.mustache

############################## DO NOT EDIT: GENERATED FILE ##############################

Description: McpDownloadResponseApi
*/

import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from "redux-query"
import * as runtime from "../src/runtime"
import { McpDownloadResponse, McpDownloadResponseFromJSON, McpDownloadResponseToJSON } from "../model"

export interface DeleteMcpDownloadResponseRequest {
	id: string
}

export interface GetMcpDownloadResponseRequest {
	id: string
}

export interface PostMcpDownloadResponseRequest {
	mcpDownloadResponse: McpDownloadResponse
}

export interface UpdateMcpDownloadResponseRequest {
	id: string
	mcpDownloadResponse: McpDownloadResponse
}

/**
 * Deletes a specific McpDownloadResponse.
 * Delete a McpDownloadResponse.
 */
function deleteMcpDownloadResponseRaw<T>(
	requestParameters: DeleteMcpDownloadResponseRequest,
	requestConfig: runtime.TypedQueryConfig<T, void> = {},
): QueryConfig<T> {
	if (requestParameters.id === null || requestParameters.id === undefined) {
		throw new runtime.RequiredError(
			"id",
			"Required parameter requestParameters.id was null or undefined when calling deleteMcpDownloadResponse.",
		)
	}

	let queryParameters = null

	const headerParameters: runtime.HttpHeaders = {}

	const { meta = {} } = requestConfig

	const config: QueryConfig<T> = {
		url: `${runtime.Configuration.basePath}/McpDownloadResponse/{id}`.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		),
		meta,
		update: requestConfig.update,
		queryKey: requestConfig.queryKey,
		optimisticUpdate: requestConfig.optimisticUpdate,
		force: requestConfig.force,
		rollback: requestConfig.rollback,
		options: {
			method: "DELETE",
			headers: headerParameters,
		},
		body: queryParameters,
	}

	const { transform: requestTransform } = requestConfig
	if (requestTransform) {
	}

	return config
}

/**
 * Deletes a specific McpDownloadResponse.
 * Delete a McpDownloadResponse.
 */
export function deleteMcpDownloadResponse<T>(
	requestParameters: DeleteMcpDownloadResponseRequest,
	requestConfig?: runtime.TypedQueryConfig<T, void>,
): QueryConfig<T> {
	return deleteMcpDownloadResponseRaw(requestParameters, requestConfig)
}

/**
 * Retrieves a single McpDownloadResponse for a specific uid.
 * Retrieve a single McpDownloadResponse
 */
function getMcpDownloadResponseRaw<T>(
	requestParameters: GetMcpDownloadResponseRequest,
	requestConfig: runtime.TypedQueryConfig<T, McpDownloadResponse> = {},
): QueryConfig<T> {
	if (requestParameters.id === null || requestParameters.id === undefined) {
		throw new runtime.RequiredError(
			"id",
			"Required parameter requestParameters.id was null or undefined when calling getMcpDownloadResponse.",
		)
	}

	let queryParameters = null

	const headerParameters: runtime.HttpHeaders = {}

	const { meta = {} } = requestConfig

	const config: QueryConfig<T> = {
		url: `${runtime.Configuration.basePath}/McpDownloadResponse/{id}`.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		),
		meta,
		update: requestConfig.update,
		queryKey: requestConfig.queryKey,
		optimisticUpdate: requestConfig.optimisticUpdate,
		force: requestConfig.force,
		rollback: requestConfig.rollback,
		options: {
			method: "GET",
			headers: headerParameters,
		},
		body: queryParameters,
	}

	const { transform: requestTransform } = requestConfig
	if (requestTransform) {
		config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(McpDownloadResponseFromJSON(body), text)
	}

	return config
}

/**
 * Retrieves a single McpDownloadResponse for a specific uid.
 * Retrieve a single McpDownloadResponse
 */
export function getMcpDownloadResponse<T>(
	requestParameters: GetMcpDownloadResponseRequest,
	requestConfig?: runtime.TypedQueryConfig<T, McpDownloadResponse>,
): QueryConfig<T> {
	return getMcpDownloadResponseRaw(requestParameters, requestConfig)
}

/**
 * Retrieves a list of McpDownloadResponses.
 * Retrieve a list of McpDownloadResponses
 */
function getMcpDownloadResponseListRaw<T>(
	requestConfig: runtime.TypedQueryConfig<T, Array<McpDownloadResponse>> = {},
): QueryConfig<T> {
	let queryParameters = null

	const headerParameters: runtime.HttpHeaders = {}

	const { meta = {} } = requestConfig

	const config: QueryConfig<T> = {
		url: `${runtime.Configuration.basePath}/McpDownloadResponse`,
		meta,
		update: requestConfig.update,
		queryKey: requestConfig.queryKey,
		optimisticUpdate: requestConfig.optimisticUpdate,
		force: requestConfig.force,
		rollback: requestConfig.rollback,
		options: {
			method: "GET",
			headers: headerParameters,
		},
		body: queryParameters,
	}

	const { transform: requestTransform } = requestConfig
	if (requestTransform) {
		config.transform = (body: ResponseBody, text: ResponseBody) =>
			requestTransform(body.map(McpDownloadResponseFromJSON), text)
	}

	return config
}

/**
 * Retrieves a list of McpDownloadResponses.
 * Retrieve a list of McpDownloadResponses
 */
export function getMcpDownloadResponseList<T>(
	requestConfig?: runtime.TypedQueryConfig<T, Array<McpDownloadResponse>>,
): QueryConfig<T> {
	return getMcpDownloadResponseListRaw(requestConfig)
}

/**
 * Creates a new McpDownloadResponse.
 * Create a new McpDownloadResponse
 */
function postMcpDownloadResponseRaw<T>(
	requestParameters: PostMcpDownloadResponseRequest,
	requestConfig: runtime.TypedQueryConfig<T, McpDownloadResponse> = {},
): QueryConfig<T> {
	if (requestParameters.mcpDownloadResponse === null || requestParameters.mcpDownloadResponse === undefined) {
		throw new runtime.RequiredError(
			"mcpDownloadResponse",
			"Required parameter requestParameters.mcpDownloadResponse was null or undefined when calling postMcpDownloadResponse.",
		)
	}

	let queryParameters = null

	const headerParameters: runtime.HttpHeaders = {}

	headerParameters["Content-Type"] = "application/json"

	const { meta = {} } = requestConfig

	const config: QueryConfig<T> = {
		url: `${runtime.Configuration.basePath}/McpDownloadResponse`,
		meta,
		update: requestConfig.update,
		queryKey: requestConfig.queryKey,
		optimisticUpdate: requestConfig.optimisticUpdate,
		force: requestConfig.force,
		rollback: requestConfig.rollback,
		options: {
			method: "POST",
			headers: headerParameters,
		},
		body: queryParameters || McpDownloadResponseToJSON(requestParameters.mcpDownloadResponse),
	}

	const { transform: requestTransform } = requestConfig
	if (requestTransform) {
		config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(McpDownloadResponseFromJSON(body), text)
	}

	return config
}

/**
 * Creates a new McpDownloadResponse.
 * Create a new McpDownloadResponse
 */
export function postMcpDownloadResponse<T>(
	requestParameters: PostMcpDownloadResponseRequest,
	requestConfig?: runtime.TypedQueryConfig<T, McpDownloadResponse>,
): QueryConfig<T> {
	return postMcpDownloadResponseRaw(requestParameters, requestConfig)
}

/**
 * Updates an existing McpDownloadResponse.
 * Update an existing McpDownloadResponse
 */
function updateMcpDownloadResponseRaw<T>(
	requestParameters: UpdateMcpDownloadResponseRequest,
	requestConfig: runtime.TypedQueryConfig<T, McpDownloadResponse> = {},
): QueryConfig<T> {
	if (requestParameters.id === null || requestParameters.id === undefined) {
		throw new runtime.RequiredError(
			"id",
			"Required parameter requestParameters.id was null or undefined when calling updateMcpDownloadResponse.",
		)
	}

	if (requestParameters.mcpDownloadResponse === null || requestParameters.mcpDownloadResponse === undefined) {
		throw new runtime.RequiredError(
			"mcpDownloadResponse",
			"Required parameter requestParameters.mcpDownloadResponse was null or undefined when calling updateMcpDownloadResponse.",
		)
	}

	let queryParameters = null

	const headerParameters: runtime.HttpHeaders = {}

	headerParameters["Content-Type"] = "application/json"

	const { meta = {} } = requestConfig

	const config: QueryConfig<T> = {
		url: `${runtime.Configuration.basePath}/McpDownloadResponse/{id}`.replace(
			`{${"id"}}`,
			encodeURIComponent(String(requestParameters.id)),
		),
		meta,
		update: requestConfig.update,
		queryKey: requestConfig.queryKey,
		optimisticUpdate: requestConfig.optimisticUpdate,
		force: requestConfig.force,
		rollback: requestConfig.rollback,
		options: {
			method: "PUT",
			headers: headerParameters,
		},
		body: queryParameters || McpDownloadResponseToJSON(requestParameters.mcpDownloadResponse),
	}

	const { transform: requestTransform } = requestConfig
	if (requestTransform) {
		config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(McpDownloadResponseFromJSON(body), text)
	}

	return config
}

/**
 * Updates an existing McpDownloadResponse.
 * Update an existing McpDownloadResponse
 */
export function updateMcpDownloadResponse<T>(
	requestParameters: UpdateMcpDownloadResponseRequest,
	requestConfig?: runtime.TypedQueryConfig<T, McpDownloadResponse>,
): QueryConfig<T> {
	return updateMcpDownloadResponseRaw(requestParameters, requestConfig)
}
